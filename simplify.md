# 本文用处

​	根据标题思考设计原则和设计模式是如何实现的，以及他们的作用。并就我自己的理解进行简单说明，方便查看。

# 类之间的表示方式

## 关联关系

### 单向关联

### 双向关联

### 自关联

## 聚合关系

## 组合关系

## 依赖关系

## 集成关系

## 实现关系

# 软件设计原则

## 开闭原则

​	对扩展开放，对修改关闭

## 里氏代换原则

​	任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

## 依赖倒转原则

​	高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

## 接口隔离原则

​	客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。

## 迪米特法则

​	如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

## 合成复用原则

​	尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

# 设计模式

## 创建者模式

### 单例模式

#### 饿汉式

​	在类加载时就会创建该类的单实例对象。常用静态方法或静态代码块实现。优点是比较方便，缺点是即使没有被使用，也会创建单例对象，浪费内存空间

#### 懒汉式

##### 线程不安全

​	直接在获取实例的方法中判断实例是否为空，如果为则创建实例返回，否则直接返回。可能线程不安全，因为两个线程可能同时判断对象是否为空，然后都进行实例的创建，破坏了单例模式的原则。if(instance == null){return new Instance();}

##### 线程安全

​	1.加synchronized关键字。2.双重检查锁。3.枚举类。4.静态内部类

#### 问题

​	序列化后会破坏单例，解决方法是在类中增加readResolve()方法

### 工厂模式

​	工厂模式主要是为了解耦

#### 简单工厂

​	简单工厂不属于设计模式，而是一种编程习惯。将各种对象的创建封装在一个类中，用if else的方式判断实例化那个类，实现细节全部在这个类中，不符合开闭原则。但是另一方面调用者省去了修改的麻烦，确实的达到了解耦的目的。

#### 工厂方法

​	首先需要一个抽象工厂类，它是顶层抽象，一般是一个接口。其次需要具体工厂类，具体工厂类需要实现抽象工厂接口，并返回需要的对象实例，不同的具体工厂类返回不同的类的实例。客户端在调用时，需要知道使用哪个具体的类的实例进而决定使用哪个具体工厂来创建对象。缺点也比较明显，没需要一个类的实例，就需要增加一个具体工厂来创建实例，会造成类爆炸。

#### 抽象工厂

​	抽象工厂也有四个角色：抽象工厂、具体工厂、抽象产品、具体产品。抽象工厂和上面的工厂方法不同的是，一个具体工厂中可以创建多个类型的实例（产品），这样可以一定程度的避免类爆炸。如在上面的工厂方法中，创建电脑工厂中只能创建电脑类的实例，创建手机的工厂方法中只能创建手机类的实例。而在抽象工厂中，创建电脑类的实例和创建手机类的实例都在创建电子产品工厂中，这样一来一定程度的避免类爆炸。但是如果未来增加了创建平板的功能，所有的创建电子产品工厂都需要增加对创建平板方法的实现。

#### 配置文件

​	可以通过配置文件的方式，将不同类的全限定类名的路径放在配置文件中，在工程加载时将配置和类的对应关系放在全局的map中，客户端调用时只需要传入配置名即可得到想要的对象实例了

### 原型模式

​	原型模式是通过clone()方法得到一个对象，需要实现Cloneable接口。克隆模式包括深克隆和浅克隆

### 建造者模式

​    将一个复杂对象的创建与他的表示分离，使得同样的构建过程可以创建不同的表示。如一个产品类X，其中包含ABCD四个属性，这四个属性可能会经常性的发生变化（但是他们之间的构件顺序是确定的），那么调用者就不知道如何得到这个产品类X，往往需要知道它的实现细节才能更好的构件产品X类。此时我们需要一个Builder抽象类，这个类中聚合了X类，并且提供了实现ABCD的四个抽象方法，以及create（创建X类的方法）方法。当ABCD有一种实现方式时，需要创建一个具体的Builder类来集成抽象Builder，这个具体Builder负责实现ABCD所有属性。最后需要一个指挥者类来负责ABCD的实现顺序，指挥者类聚合了Builder（抽象的）。最后客户端只需要创建指挥者类并传入具体的Builder实现类即可。

## 结构模式

### 代理模式

​	当不适合或者不能访问真实对象时，需要使用代理模式。代理模式还可以增加目标对象

#### 静态代理

​	静态代理就是把目标对象封装了一层（聚合目标对象），然后在提供的方法中调用目标对象的方法，还可以在调用前后对目标方法进行增强。调用者通过调用封装类提供的方法来调用目标对象。

#### 动态代理

##### JDK动态代理

##### CGLIB动态代理

### 适配器模式

​	如我们提供了一个接口A，但是客户端调用方式和接口A格式不一致，需要新增一个适配器进行适配，客户端通过调用适配器类中的方法来调用接口A。和代理模式的区别：代理模式通过代理类调用的是原接口，适配器模式需要对原有接口调用进行封装。

#### 类适配器

​	通过集成的方式实现

#### 对象适配器

​	通过聚合的方式实现，推荐这种方式，耦合度较低

### 装饰者模式

​	在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。如有一个接口A，产品类B实现了接口A，为了给产品B的方法增加一些功能，再创建一个装饰者类C也实现接口A，在C中聚合A产品类，客户端调用装饰者类并传入B对象作为入参，装饰者类中调用产品类B的方法，并在产品类B个方法的前后增加一些功能进行增强。代理、适配器、装饰者都能对目标方法进行增加，但是其目的不一样。代理是为了隐藏目标对象，适配器是为了做适配，装饰者是为了不改变原来对象的结构的基础上进行增强，装饰者模式需要给装饰者类传递原对象作为入参。

### 桥接模式

​	当一个类存在两个独立变化的维度，并且都需要动态扩展时使用桥接模式。如有三种图形正方形、长方形、三角形，又有三种颜色黄色、红色、绿色，如果我们使用继承的方式得到带颜色的图形需要让正方形继承黄色、红色、绿色，同理还有其他图形，一共至少需要九个类，如果图形或者颜色增加了还要继续增加类并进行继承。桥接模式：需要一个颜色接口，红黄绿分别实现颜色接口，然后需要一个形状抽象类，聚合抽象的颜色接口，并提供有参构造函数和一个抽象方法。再分别定义正方形、长方形、三角形具体实现去实现形状接口，未来如果要得到一个红色正方形，我们只需要定义一个红色对象，然后传入正方形的构造函数中即可。避免了类爆炸。https://www.cnblogs.com/lfxiao/p/6815760.html

### 外观模式

​	为多个子系统对外提供一个共同的接口。如有A、B、C三个接口，客户端需要分别调用他们去实现功能，此时可以定义一个接口D，将ABC聚合进来，对外部提供统一调用方法即可，客户端调用非常方便。但是外观模式不符合开闭原则。

### 组合模式

​	适合递归树形结构。 顶层抽象类定义所有属性和方法。递归过程中分为父层级和子层级，各自实现顶层抽象接口，并且重写自己感兴趣的方法。父层级还需要集合顶层抽象的集合。

### 享元模式

​	减少内存的使用，复用对象。当对象的可以分为不变和变化两部分状态时，不变的可以封装起来，变化的由外部参数传如。并且有工厂提供模版对象，外部只需要传入参数即可

## 行为模式

### 模板模式

​	使用抽象类封装算法的步骤成为模板方法，为防止子类重写模板方法将其定位为final。抽象类中还需要定义抽象方法、具体方法和钩子方法。其中抽象方法可能是变化的，延迟到具体子类中实现，具体方法基本是不会发生变化的在抽象类中直接定义，钩子方法也是具体实现的，子类中根据情况判断是否要重写，一般是布尔值的返回类型，用来做逻辑判断使用。

### 策略模式

​	策略接口定义行为，具体策略实现接口。环境类聚合策略接口，客户端调用环境类，传入具体策略实现即可。

### 命令模式

​	具体实现者类；抽象命令接口；具体命令类实现抽象命令接口并持有具体实现者对象，若要有不同的实现者可定义不同的具体命令类；请求者类持有命令对象集合，并对外提供命令功能，命令方法里面调用具体实现着对象的方法。为了解耦，不让客户端直接调用具体实现者

### 责任链

​	类似于chain，也类似于工作流。首先需要个上层抽象类，具体的一个个实现就是责任链，外部通过add或set设置每个链的下一个处理链。

### 状态模式

​	我感觉没啥用

### 观察者模式

​	需要一个抽象主题接口，一个具体主题实现；一个抽象观察接口，一个具体观察者实现。抽象主题接口一般需要三个方法：添加订阅者，删除订阅者以及通知所有订阅者接口。具体注意实现需要聚合观察者集合（聚合抽象观察者即可），在实现添加和删除时对list中的成员add或remove即可，通知就是循环list，调用具体观察者的update方法。

### 中介者模式

​	通过中介，将消息传递给不同的类。首先需要一个抽象中介者类，定义发送消息的方法，入参是消息体和抽象同事类。具体的中介者类实现抽象中介者，里面聚合了不同的具体同事者类。抽象同事者类中需要聚合中介者抽抽象，在客户端调用时传入具体的中介者和其他入参。具体同事者类提供构造函数和调用中介者的消息通讯的方法。

### 迭代器模式

​	其实就是自己写了一个迭代器的实现，没啥用感觉

### 访问者模式

​	接口A，有两个实现B和C。另一个接口P要访问B和C，则接口P需要定义两个抽象方法分别将B和C作为参数传递，同时A接口提供的抽象方法需要使用P做为入参传递。实现了P接口的M和N要将两个方法都实现。最后需要一个对象结构类，其中聚合了A接口的集合，提供一个对外访问的方法，将P接口作为入参，然后循环A接口的集合，调用A接口的抽象方法，这样A接口抽象方法的实现类中既有P的实现类，又有自己的实现逻辑。违背了开闭原则和依赖倒转原则。适合对象结构比较稳定的情况使用

### 备忘录模式

简而言之就是用另一个对象存储当前对象的数据，做一个备份方便恢复，比如数据库事务的回复。白盒备忘录：需要一个发起者对象（等待被拷贝对象），一个备忘录对象，其中备忘录对象的属性和发起者对象是一样的，发起者对象有保存和恢复方法，保存就是用当前属性的值创建一个备忘录对象放回，恢复方法就是用备忘录对象的属性覆盖发起者对象的属性值，最后需要一个备忘录管理对象，它聚合了备忘录对象，备忘录对象都从这个管理对象中存储和获取。黑盒备忘录：将备忘录对象作为内部类放在发起者对象内部，避免外部对其进行修改

### 解释器模式

我理解是一种递归的实现，将复杂的可递归调用的表达式做成可递归的方式。需要一个表达式类，在表达式类中在聚合左右表达式，通过算法将两个表达式进行连接