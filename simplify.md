# 本文用处

​	根据标题思考设计原则和设计模式是如何实现的，以及他们的作用。并就我自己的理解进行简单说明，方便查看。

# 类之间的表示方式

## 关联关系

### 单向关联

### 双向关联

### 自关联

## 聚合关系

## 组合关系

## 依赖关系

## 集成关系

## 实现关系

# 软件设计原则

## 开闭原则

​	对扩展开放，对修改关闭

## 里氏代换原则

​	任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

## 依赖倒转原则

​	高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。

## 接口隔离原则

​	客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。

## 迪米特法则

​	如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

## 合成复用原则

​	尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

# 设计模式

## 创建者模式

### 单例模式

#### 饿汉式

​	在类加载时就会创建该类的单实例对象。常用静态方法或静态代码块实现。优点是比较方便，缺点是即使没有被使用，也会创建单例对象，浪费内存空间

#### 懒汉式

##### 线程不安全

​	直接在获取实例的方法中判断实例是否为空，如果为则创建实例返回，否则直接返回。可能线程不安全，因为两个线程可能同时判断对象是否为空，然后都进行实例的创建，破坏了单例模式的原则。if(instance == null){return new Instance();}

##### 线程安全

​	1.加synchronized关键字。2.双重检查锁。3.枚举类。4.静态内部类

#### 问题

​	序列化后会破坏单例，解决方法是在类中增加readResolve()方法

### 工厂模式

​	工厂模式主要是为了解耦

#### 简单工厂

​	简单工厂不属于设计模式，而是一种编程习惯。将各种对象的创建封装在一个类中，用if else的方式判断实例化那个类，实现细节全部在这个类中，不符合开闭原则。但是另一方面调用者省去了修改的麻烦，确实的达到了解耦的目的。

#### 工厂方法

​	首先需要一个抽象工厂类，它是顶层抽象，一般是一个接口。其次需要具体工厂类，具体工厂类需要实现抽象工厂接口，并返回需要的对象实例，不同的具体工厂类返回不同的类的实例。客户端在调用时，需要知道使用哪个具体的类的实例进而决定使用哪个具体工厂来创建对象。缺点也比较明显，没需要一个类的实例，就需要增加一个具体工厂来创建实例，会造成类爆炸。

#### 抽象工厂

​	抽象工厂也有四个角色：抽象工厂、具体工厂、抽象产品、具体产品。抽象工厂和上面的工厂方法不同的是，一个具体工厂中可以创建多个类型的实例（产品），这样可以一定程度的避免类爆炸。如在上面的工厂方法中，创建电脑工厂中只能创建电脑类的实例，创建手机的工厂方法中只能创建手机类的实例。而在抽象工厂中，创建电脑类的实例和创建手机类的实例都在创建电子产品工厂中，这样一来一定程度的避免类爆炸。但是如果未来增加了创建平板的功能，所有的创建电子产品工厂都需要增加对创建平板方法的实现。

#### 配置文件

​	可以通过配置文件的方式，将不同类的全限定类名的路径放在配置文件中，在工程加载时将配置和类的对应关系放在全局的map中，客户端调用时只需要传入配置名即可得到想要的对象实例了

### 原型模式

​	原型模式是通过clone()方法得到一个对象，需要实现Cloneable接口。克隆模式包括深克隆和浅克隆

### 建造者模式

​    将一个复杂对象的创建与他的表示分离，使得同样的构建过程可以创建不同的表示。如一个产品类X，其中包含ABCD四个属性，这四个属性可能会经常性的发生变化（但是他们之间的构件顺序是确定的），那么调用者就不知道如何得到这个产品类X，往往需要知道它的实现细节才能更好的构件产品X类。此时我们需要一个Builder抽象类，这个类中聚合了X类，并且提供了实现ABCD的四个抽象方法，以及create（创建X类的方法）方法。当ABCD有一种实现方式时，需要创建一个具体的Builder类来集成抽象Builder，这个具体Builder负责实现ABCD所有属性。最后需要一个指挥者类来负责ABCD的实现顺序，指挥者类聚合了Builder（抽象的）。最后客户端只需要创建指挥者类并传入具体的Builder实现类即可。

## 结构模式

### 代理模式

​	当不适合或者不能访问真实对象时，需要使用代理模式。代理模式还可以增加目标对象

#### 静态代理

​	静态代理就是把目标对象封装了一层（聚合目标对象），然后在提供的方法中调用目标对象的方法，还可以在调用前后对目标方法进行增强。调用者通过调用封装类提供的方法来调用目标对象。

#### 动态代理

##### JDK动态代理

##### CGLIB动态代理

### 适配器模式

​	如我们提供了一个接口A，但是客户端调用方式和接口A格式不一致，需要新增一个适配器进行适配，客户端通过调用适配器类中的方法来调用接口A。和代理模式的区别：代理模式通过代理类调用的是原接口，适配器模式需要对原有接口调用进行封装。

#### 类适配器

​	通过集成的方式实现

#### 对象适配器

​	通过聚合的方式实现，推荐这种方式，耦合度较低

### 装饰者模式

​	在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。如有一个接口A，产品类B实现了接口A，为了给产品B的方法增加一些功能，再创建一个装饰者类C也实现接口A，在C中聚合A产品类，客户端调用装饰者类并传入B对象作为入参，装饰者类中调用产品类B的方法，并在产品类B个方法的前后增加一些功能进行增强。代理、适配器、装饰者都能对目标方法进行增加，但是其目的不一样。代理是为了隐藏目标对象，适配器是为了做适配，装饰者是为了不改变原来对象的结构的基础上进行增强，装饰者模式需要给装饰者类传递原对象作为入参。

### 桥接模式

​	当一个类存在两个独立变化的维度，并且都需要动态扩展时使用桥接模式。如有三种图形正方形、长方形、三角形，又有三种颜色黄色、红色、绿色，如果我们使用继承的方式得到带颜色的图形需要让正方形继承黄色、红色、绿色，同理还有其他图形，一共至少需要九个类，如果图形或者颜色增加了还要继续增加类并进行继承。桥接模式：需要一个颜色接口，红黄绿分别实现颜色接口，然后需要一个形状抽象类，聚合抽象的颜色接口，并提供有参构造函数和一个抽象方法。再分别定义正方形、长方形、三角形具体实现去实现形状接口，未来如果要得到一个红色正方形，我们只需要定义一个红色对象，然后传入正方形的构造函数中即可。避免了类爆炸。https://www.cnblogs.com/lfxiao/p/6815760.html

### 外观模式

​	为多个子系统对外提供一个共同的接口。如有A、B、C三个接口，客户端需要分别调用他们去实现功能，此时可以定义一个接口D，将ABC聚合进来，对外部提供统一调用方法即可，客户端调用非常方便。但是外观模式不符合开闭原则。

### 组合模式

​	适合递归树形结构。 顶层抽象类定义所有属性和方法。递归过程中分为父层级和子层级，各自实现顶层抽象接口，并且重写自己感兴趣的方法。父层级还需要集合顶层抽象的集合。





